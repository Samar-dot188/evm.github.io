<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECOVERSE ‚Äì 3D Environment Builder</title>
    <style>
        :root {
            --glass: rgba(255, 255, 255, 0.15);
            --glass-heavy: rgba(255, 255, 255, 0.85);
            --primary: #2ecc71;
            --secondary: #3498db;
            --danger: #e74c3c;
            --dark: #2c3e50;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
            background: #0f172a;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
            transition: opacity 0.5s;
        }

        .hidden {
            display: none !important;
        }

        .panel {
            background: var(--glass-heavy);
            padding: 2.5rem;
            border-radius: 24px;
            width: 90%;
            max-width: 480px;
            text-align: center;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        h1 {
            margin-top: 0;
            color: var(--dark);
            letter-spacing: -1px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .side-bar {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .top-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            align-items: center;
            pointer-events: auto;
            width: max-content;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        /* Buttons */
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .tool-btn {
            background: white;
            color: var(--dark);
            border: 2px solid transparent;
            text-align: left;
            padding: 8px 12px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tool-btn.active {
            border-color: var(--secondary);
            background: #e0f2fe;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            margin: 20px 0;
            border-radius: 12px;
            border: 2px solid #ddd;
            font-size: 1rem;
            box-sizing: border-box;
        }

        /* Leaderboard */
        #leaderboard-list {
            text-align: left;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            overflow-x: visible;
            padding-right: 6px;
        }

        .lb-entry.me {
            background: #3498db33;
            border-radius: 8px;
            outline: 2px solid #3498db88;
        }


        .lb-entry {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
            position: relative;
            z-index: 2;
        }

        /* AI Result */
        .ai-box {
            background: #f8fafc;
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-size: 0.9rem;
        }

        .lb-entry.top {
            background: linear-gradient(90deg, #ffd70033, #fff8);
            border-radius: 10px;
            font-weight: bold;
            position: relative;
            z-index: 1;

            /* Side glow effect */
            box-shadow:
                inset 6px 0 12px -4px #ffd70088,
                /* left glow */
                inset -6px 0 12px -4px #ffd70088;
            /* right glow */

            animation: pulse-sides 1.5s infinite;
        }



        @keyframes pulse-sides {
            0% {
                box-shadow: inset 4px 0 10px -3px #ffd70066,
                    inset -4px 0 10px -3px #ffd70066;
            }

            50% {
                box-shadow: inset 6px 0 14px -2px #ffd700cc,
                    inset -6px 0 14px -2px #ffd700cc;
            }

            100% {
                box-shadow: inset 4px 0 10px -3px #ffd70066,
                    inset -4px 0 10px -3px #ffd70066;
            }
        }

        .lb-entry.top strong::after {
            content: " üëë";
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <div class="top-bar">
            <div class="stat-card">üåç <span id="live-score">0</span>
                pts</div>
            <div class="stat-card">üå´Ô∏è <span id="pollution">0</span>%</div>
            <div class="stat-card">üòä <span id="happiness">100</span>%</div>
            <button class="btn" id="eval-btn" onclick="evaluateCity()" disabled style="width: auto;">Evaluate
                (0/10)</button>
            <button class="btn" style="background:var(--danger); width: auto;" onclick="setTool('delete')">üóëÔ∏è
                Delete</button>
        </div>

        <div class="side-bar">
            <div style="color:white; font-size: 0.7rem; font-weight: bold; margin-bottom: 5px;">ENERGY</div>
            <button class="btn tool-btn" onclick="setTool('solar')" data-type="solar">‚òÄÔ∏è Solar Plant</button>
            <button class="btn tool-btn" onclick="setTool('wind')" data-type="wind">üå¨Ô∏è Wind Turbine</button>
            <button class="btn tool-btn" onclick="setTool('coal')" data-type="coal">üè≠ Coal Factory</button>

            <div style="color:white; font-size: 0.7rem; font-weight: bold; margin: 10px 0 5px;">LIVING</div>
            <button class="btn tool-btn" onclick="setTool('eco')" data-type="eco">üè° Eco House</button>
            <button class="btn tool-btn" onclick="setTool('apart')" data-type="apart">üè¢ Apartment</button>
            <button class="btn tool-btn" onclick="setTool('tree')" data-type="tree">üå≥ Trees</button>

            <div style="color:white; font-size: 0.7rem; font-weight: bold; margin: 10px 0 5px;">TRANSIT</div>
            <button class="btn tool-btn" onclick="setTool('bike')" data-type="bike">üö≤ Bike Station</button>
            <button class="btn tool-btn" onclick="setTool('car')" data-type="car">üöó Car Park</button>
            <button class="btn tool-btn" onclick="setTool('bus')" data-type="bus">üöç Bus Terminal</button>

            <div style="color:white; font-size: 0.7rem; font-weight: bold; margin: 10px 0 5px;">WASTE</div>
            <button class="btn tool-btn" onclick="setTool('recycle')" data-type="recycle">‚ôªÔ∏è Recycle Center</button>
            <button class="btn tool-btn" onclick="setTool('dump')" data-type="dump">üóëÔ∏è Dump Yard</button>
            <button class="btn tool-btn" onclick="setTool('water')" data-type="water">üíß Water Tank</button>
        </div>
    </div>

    <!-- Screen: Start -->
    <div id="screen-start" class="overlay">
        <div class="panel">
            <h1>ECOVERSE</h1>
            <p>Design a sustainable 3D utopia. Drag and place assets to
                optimize the environment.</p>
            <input type="text" id="playerName" placeholder="Enter Architect Name" maxlength="15">
            <button class="btn" onclick="startGame()">Start Project</button>
            <button class="btn" style="margin-top:10px; background:var(--secondary)"
                onclick="showLeaderboard()">Leaderboard</button>
        </div>
    </div>

    <!-- Screen: Result -->
    <div id="screen-result" class="overlay hidden">
        <div class="panel">
            <h1>Project Results</h1>
            <div style="font-size: 2.5rem; color: var(--primary); font-weight: bold;" id="final-score">0</div>
            <div style="margin-bottom: 20px;">Rating: <span id="final-rating">0</span>/10</div>

            <div class="ai-box">
                <strong>ü§ñ AI Assessment:</strong>
                <p id="ai-feedback">Analyzing...</p>
                <hr style="border:0; border-top:1px solid #ddd;">
                <p id="ai-tip"></p>
            </div>

            <button class="btn" onclick="location.reload()">Build New
                City</button>
        </div>
    </div>

    <!-- Screen: Leaderboard -->
    <div id="screen-leaderboard" class="overlay hidden">
        <div class="panel">
            <h1>Global Leaderboard</h1>
            <div id="leaderboard-list"></div>
            <button class="btn" onclick="closeLeaderboard()">Back</button>
            <button class="btn" style="background:var(--danger); margin-top:10px" onclick="adminClear()">Reset
                History</button>

        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAjkP1QVCUwf3ef5A16lbQeRJ3VpcwZNlc",
            authDomain: "ecoverse-7530e.firebaseapp.com",
            projectId: "ecoverse-7530e",
            storageBucket: "ecoverse-7530e.appspot.com",
            messagingSenderId: "588006729677",
            appId: "1:588006729677:web:9e697cf1c7653c8871c684"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        let leaderboardUnsub = null;
    </script>

    <script>
        // --- Config ---
        const OPENAI_KEY = "";
        const GRID_SIZE = 10;
        const CELL_SIZE = 2;
        const MIN_OBJECTS = 10;

        const OBJ_CONFIG = {
            solar: { score: 15, label: "Solar Plant" },
            wind: { score: 15, label: "Wind Turbine" },
            coal: { score: -25, label: "Coal Factory" },
            eco: { score: 10, label: "Eco House" },
            apart: { score: 5, label: "Apartment" },
            tree: { score: 10, label: "Trees" },
            bike: { score: 10, label: "Bike Station" },
            car: { score: -10, label: "Car Park" },
            bus: { score: 12, label: "Bus Terminal" },
            recycle: { score: 15, label: "Recycle Center" },
            dump: { score: -20, label: "Dump Yard" },
            water: { score: 10, label: "Water Tank" }
        };

        // --- State ---
        let scene, camera, renderer, controls, raycaster;
        let gridHelper, ground;
        let selectedTool = 'solar';
        let placedObjects = [];
        let playerName = "";
        let mouse = new THREE.Vector2();
        let hoverMesh;
        let ghost; // Placement ghost preview

        // --- Initialization ---
        window.onload = init;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d8ef);
            scene.fog = new THREE.Fog(0xa0d8ef, 15, 60);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(20, 40, 20);
            sun.castShadow = true;
            sun.shadow.camera.left = -20;
            sun.shadow.camera.right = 20;
            sun.shadow.camera.top = 20;
            sun.shadow.camera.bottom = -20;
            sun.shadow.mapSize.width = 1024;
            sun.shadow.mapSize.height = 1024;
            scene.add(sun);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x86c06a });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            gridHelper = new THREE.GridHelper(GRID_SIZE * CELL_SIZE, GRID_SIZE, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            raycaster = new THREE.Raycaster();

            // Hover indicator
            const hoverGeo = new THREE.BoxGeometry(CELL_SIZE - 0.1, 0.05, CELL_SIZE - 0.1);
            const hoverMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
            hoverMesh = new THREE.Mesh(hoverGeo, hoverMat);
            scene.add(hoverMesh);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('pointerdown', onMouseDown);

            // Initial Ghost
            setTool('solar');

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(event) {
            if (event.button !== 0) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([ground, ...placedObjects.map(o => o.mesh)], true);

            if (intersects.length > 0) {
                const intersect = intersects[0];

                if (selectedTool === 'delete') {
                    const hitObj = placedObjects.find(o => {
                        let match = false;
                        o.mesh.traverse(child => { if (child === intersect.object) match = true; });
                        return match;
                    });
                    if (hitObj) removeObject(hitObj);
                } else {
                    // Only place on ground
                    const groundIntersect = raycaster.intersectObject(ground);
                    if (groundIntersect.length > 0) {
                        const pos = groundIntersect[0].point;
                        const gx = Math.round(pos.x / CELL_SIZE) * CELL_SIZE;
                        const gz = Math.round(pos.z / CELL_SIZE) * CELL_SIZE;

                        // Check if tile is occupied
                        const exists = placedObjects.find(o => o.x === gx && o.z === gz);
                        if (exists) removeObject(exists);

                        placeObject(gx, gz, selectedTool);
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                hoverMesh.visible = true;
                const gx = Math.round(intersects[0].point.x / CELL_SIZE) * CELL_SIZE;
                const gz = Math.round(intersects[0].point.z / CELL_SIZE) * CELL_SIZE;
                hoverMesh.position.set(gx, 0.05, gz);

                if (ghost && selectedTool !== 'delete') {
                    ghost.visible = true;
                    ghost.position.set(gx, 0, gz);
                }
            } else {
                hoverMesh.visible = false;
                if (ghost) ghost.visible = false;
            }

            // Animate objects
            placedObjects.forEach(obj => {
                if (obj.type === 'wind') {
                    const blades = obj.mesh.getObjectByName('blades');
                    if (blades) blades.rotation.z += 0.1;
                }
                // Moving traffic logic
                if (obj.type === 'car' || obj.type === 'bus') {
                    obj.mesh.position.x += 0.02;
                    if (obj.mesh.position.x > (GRID_SIZE * CELL_SIZE / 2)) {
                        obj.mesh.position.x = -(GRID_SIZE * CELL_SIZE / 2);
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // --- Model Creation Logic ---
        function createModel(type) {
            const group = new THREE.Group();

            switch (type) {
                case 'solar':
                    const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                    stand.position.y = 0.25;
                    group.add(stand);
                    const panel = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.05, 1), new THREE.MeshStandardMaterial({ color: 0x1a237e }));
                    panel.position.y = 0.6;
                    panel.rotation.x = -Math.PI / 6;
                    group.add(panel);
                    const wireframe = new THREE.Mesh(new THREE.BoxGeometry(1.41, 0.06, 1.01), new THREE.MeshStandardMaterial({ color: 0x3f51b5, wireframe: true }));
                    panel.add(wireframe);
                    break;

                case 'wind':
                    const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 3), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    tower.position.y = 1.5;
                    group.add(tower);
                    const blades = new THREE.Group();
                    blades.name = 'blades';
                    blades.position.y = 3;
                    blades.position.z = 0.2;
                    group.add(blades);
                    for (let i = 0; i < 3; i++) {
                        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.4, 0.05), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        blade.position.y = 0.7;
                        const bGroup = new THREE.Group();
                        bGroup.rotation.z = (i * Math.PI * 2) / 3;
                        bGroup.add(blade);
                        blades.add(bGroup);
                    }
                    break;

                case 'coal':
                    const factoryBody = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 1.4), new THREE.MeshStandardMaterial({ color: 0x424242 }));
                    factoryBody.position.y = 0.6;
                    group.add(factoryBody);
                    const stack = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2.5), new THREE.MeshStandardMaterial({ color: 0x212121 }));
                    stack.position.set(0.4, 1.25, 0.4);
                    group.add(stack);
                    const band = new THREE.Mesh(new THREE.CylinderGeometry(0.31, 0.31, 0.2), new THREE.MeshStandardMaterial({ color: 0xc62828 }));
                    band.position.y = 2.2;
                    group.add(band);
                    break;

                case 'eco':
                    const house = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 1.2), new THREE.MeshStandardMaterial({ color: 0xfff9c4 }));
                    house.position.y = 0.4;
                    group.add(house);
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(1, 0.8, 4), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
                    roof.position.y = 1.2;
                    roof.rotation.y = Math.PI / 4;
                    group.add(roof);
                    const door = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.1), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
                    door.position.set(0, 0.25, 0.6);
                    group.add(door);
                    break;

                case 'apart':
                    const towerBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 4, 1.2), new THREE.MeshStandardMaterial({ color: 0xe0e0e0 }));
                    towerBody.position.y = 2;
                    group.add(towerBody);
                    for (let i = 0; i < 6; i++) {
                        const win = new THREE.Mesh(new THREE.BoxGeometry(1.22, 0.2, 1.22), new THREE.MeshStandardMaterial({ color: 0x81d4fa }));
                        win.position.y = 0.5 + i * 0.6;
                        group.add(win);
                    }
                    break;

                case 'tree':
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
                    trunk.position.y = 0.5;
                    group.add(trunk);
                    const fol1 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), new THREE.MeshStandardMaterial({ color: 0x1b5e20 }));
                    fol1.position.y = 1.3;
                    group.add(fol1);
                    const fol2 = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
                    fol2.position.set(0.3, 1.6, -0.2);
                    group.add(fol2);
                    break;

                case 'bike':
                    const bikeBase = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: 0x757575 }));
                    bikeBase.position.y = 0.05;
                    group.add(bikeBase);
                    for (let i = 0; i < 3; i++) {
                        const b = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.4), new THREE.MeshStandardMaterial({ color: 0x03a9f4 }));
                        b.rotation.x = Math.PI / 2;
                        b.position.set(-0.5 + i * 0.5, 0.3, 0);
                        group.add(b);
                    }
                    break;

                case 'car':
                    const carBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 0.8), new THREE.MeshStandardMaterial({ color: 0xe53935 }));
                    carBody.position.y = 0.4;
                    group.add(carBody);
                    const roofC = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.7), new THREE.MeshStandardMaterial({ color: 0xe53935 }));
                    roofC.position.y = 0.8;
                    group.add(roofC);
                    [[-0.4, 0.4], [0.4, 0.4], [-0.4, -0.4], [0.4, -0.4]].forEach(p => {
                        const w = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.2, 8), new THREE.MeshStandardMaterial({ color: 0x212121 }));
                        w.rotation.z = Math.PI / 2;
                        w.position.set(p[0], 0.2, p[1]);
                        group.add(w);
                    });
                    break;

                case 'bus':
                    const busBody = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1, 0.9), new THREE.MeshStandardMaterial({ color: 0xffeb3b }));
                    busBody.position.y = 0.6;
                    group.add(busBody);
                    const winB = new THREE.Mesh(new THREE.BoxGeometry(1.82, 0.3, 0.7), new THREE.MeshStandardMaterial({ color: 0x212121 }));
                    winB.position.y = 0.8;
                    group.add(winB);
                    break;

                case 'recycle':
                    const recBody = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 1.4), new THREE.MeshStandardMaterial({ color: 0x43a047 }));
                    recBody.position.y = 0.6;
                    group.add(recBody);
                    const sign = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                    sign.position.z = 0.71;
                    sign.position.y = 0.6;
                    recBody.add(sign);
                    break;

                case 'dump':
                    const pit = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.2, 1.8), new THREE.MeshStandardMaterial({ color: 0x546e7a }));
                    pit.position.y = 0.1;
                    group.add(pit);
                    for (let i = 0; i < 4; i++) {
                        const t = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), new THREE.MeshStandardMaterial({ color: 0x263238 }));
                        t.position.set(Math.random() - 0.5, 0.3, Math.random() - 0.5);
                        group.add(t);
                    }
                    break;

                case 'water':
                    const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 1.8), new THREE.MeshStandardMaterial({ color: 0x0288d1 }));
                    tank.position.y = 0.9;
                    group.add(tank);
                    const support = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.8, 0.2), new THREE.MeshStandardMaterial({ color: 0x9e9e9e }));
                    support.position.y = 0.9;
                    group.add(support);
                    break;
            }

            group.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return group;
        }

        function placeObject(x, z, type) {
            const model = createModel(type);
            model.position.set(x, 0, z);
            model.scale.set(0, 0, 0);
            scene.add(model);

            const start = performance.now();
            const duration = 400;
            const animateIn = (now) => {
                const elapsed = now - start;
                const progress = Math.min(elapsed / duration, 1);
                model.scale.set(progress, progress, progress);
                if (progress < 1) requestAnimationFrame(animateIn);
            };
            requestAnimationFrame(animateIn);

            placedObjects.push({ x, z, type, mesh: model });
            updateStats();
        }

        function removeObject(obj) {
            scene.remove(obj.mesh);
            placedObjects = placedObjects.filter(o => o !== obj);
            updateStats();
        }

        function updateStats() {
            let score = 0;
            let pollution = 0;

            placedObjects.forEach(o => {
                score += OBJ_CONFIG[o.type].score;

                if (o.type === 'coal' || o.type === 'dump' || o.type === 'car') pollution += 8;
                if (o.type === 'tree' || o.type === 'solar' || o.type === 'wind') pollution -= 5;
            });

            pollution = Math.max(0, Math.min(100, pollution));
            const happiness = Math.max(0, 100 - pollution + Math.floor(score / 5));

            document.getElementById('live-score').innerText = score;
            document.getElementById('pollution').innerText = pollution;
            document.getElementById('happiness').innerText = happiness;

            // Fog visual feedback
            scene.fog.near = 10 + (100 - pollution) / 4;
            scene.fog.far = 60 - pollution / 2;

            const btn = document.getElementById('eval-btn');
            const count = placedObjects.length;
            btn.disabled = count < MIN_OBJECTS;
            btn.innerText = count < MIN_OBJECTS ? `Evaluate (${count}/${MIN_OBJECTS})` : "Evaluate City";
        }

        // --- UI & Storage ---
        function startGame() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) return alert("Please enter your name!");
            playerName = name;
            document.getElementById('screen-start').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
        }

        async function evaluateCity() {
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('screen-result').classList.remove('hidden');

            const objectsList = placedObjects.map(o => OBJ_CONFIG[o.type].label).join(", ");
            const totalScore = parseInt(document.getElementById('live-score').innerText);

            let aiData;
            try {
                if (OPENAI_KEY) {
                    aiData = await askAI(objectsList);
                } else {
                    aiData = simulateAI(totalScore);
                }
            } catch (e) { aiData = simulateAI(totalScore); }

            document.getElementById('final-score').innerText = totalScore;
            document.getElementById('final-rating').innerText = aiData.rating;
            document.getElementById('ai-feedback').innerText = aiData.feedback;
            document.getElementById('ai-tip').innerText = "üí° Tip: " + aiData.tip;

            saveScore(playerName, totalScore, aiData.rating);
            if (totalScore > 100) spawnConfetti();
        }

        function simulateAI(score) {
            const rating = Math.max(1, Math.min(10, Math.floor(score / 15) + 5));
            let feedback = "A functional start to a city, but balancing industrial output with green space is key.";
            let tip = "Try adding more trees and renewable energy to boost air quality.";

            if (score > 120) {
                feedback = "Masterful design! This carbon-neutral sanctuary sets a new standard for urban living.";
                tip = "Consider optimizing high-density housing near bus terminals.";
            } else if (score < 0) {
                feedback = "An environmental disaster. The reliance on coal and waste is creating an uninhabitable zone.";
                tip = "Demolish the coal factories and replace them with wind turbines immediately.";
            }

            return { rating, feedback, tip };
        }

        async function saveScore(name, score, rating) {
            await db.collection("leaderboard").add({
                name,
                score,
                rating,
                time: Date.now()
            });
        }


        function showLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = "Loading live scores...";

            document.getElementById('screen-leaderboard').classList.remove('hidden');

            if (leaderboardUnsub) leaderboardUnsub();

            leaderboardUnsub = db.collection("leaderboard")
                .orderBy("score", "desc")
                .limit(10)
                .onSnapshot(snapshot => {

                    let html = "";
                    let rank = 1;

                    snapshot.forEach(doc => {
                        const e = doc.data();

                        const topClass = rank === 1 ? "top" : "";
                        const meClass = e.name === playerName ? "me" : "";


                        html += `
    <div class="lb-entry ${topClass} ${meClass}">
        <span>${rank}. <strong>${e.name}</strong></span>
        <span>${e.score} pts (${e.rating}/10)</span>
    </div>`;

                        rank++;
                    });

                    list.innerHTML = html || "<p>No scores yet.</p>";
                    const myRow = list.querySelector('.me');
                    if (myRow) myRow.scrollIntoView({ behavior: "smooth", block: "center" });


                });
        }
        async function clearLB() {
            if (!confirm("Delete ALL leaderboard scores?")) return;

            const snap = await db.collection("leaderboard").get();

            const batch = db.batch();

            snap.forEach(doc => {
                batch.delete(doc.ref);
            });

            await batch.commit();

            alert("Leaderboard cleared.");
        }

        function adminClear() {
            const pass = prompt("Admin password:");
            if (pass === "eco2026") clearLB();
        }






        function closeLeaderboard() {
            if (leaderboardUnsub) leaderboardUnsub();
            document.getElementById('screen-leaderboard').classList.add('hidden');
        }


        function spawnConfetti() {
            for (let i = 0; i < 100; i++) {
                const d = document.createElement('div');
                d.style.position = 'fixed'; d.style.zIndex = '2000';
                d.style.width = '8px'; d.style.height = '8px';
                d.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
                d.style.left = Math.random() * 100 + 'vw'; d.style.top = '-10px';
                document.body.appendChild(d);
                d.animate([
                    { transform: 'translateY(0) rotate(0)', opacity: 1 },
                    { transform: `translateY(100vh) rotate(${Math.random() * 720}deg)`, opacity: 0 }
                ], { duration: 2000 + Math.random() * 3000, easing: 'cubic-bezier(0,1,1,1)' }).onfinish = () => d.remove();
            }
        }

        function setTool(tool) {
            selectedTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.type === tool));

            // Manage ghost model
            if (ghost) scene.remove(ghost);
            if (tool !== 'delete') {
                ghost = createModel(tool);
                ghost.traverse(c => {
                    if (c.material) {
                        c.material = c.material.clone();
                        c.material.transparent = true;
                        c.material.opacity = 0.4;
                    }
                });
                scene.add(ghost);
            }
        }
        window.askAI = async function (objects) {
            try {
                // We call YOUR Netlify function, which safely holds the key
                const response = await fetch("/.netlify/functions/openrouter", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ objects: objects })
                });

                const data = await response.json();

                // If the function returned an error about the variable
                if (data.isVarNull) {
                    return { rating: 0, feedback: "API Key missing in Netlify settings.", tip: "Check dashboard." };
                }

                return data; // This will be the {rating, feedback, tip} from the AI
            } catch (err) {
                console.error("Function error:", err);
                return { rating: 5, feedback: "Could not connect to service.", tip: "Check your internet." };
            }
        };



    </script>
</body>

</html>
